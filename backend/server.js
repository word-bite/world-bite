// server.js

// 1. Importar os m√≥dulos
const express = require('express');
const cors = require('cors');
require('dotenv').config();
const Nexmo = require('nexmo'); 

// Importar o cliente do Prisma
const prisma = require('./config/database.js');

// Importar o servi√ßo de email
const emailService = require('./services/emailService');

// üîë IMPORTA√á√ÉO DAS ROTAS DE PRATOS
const pratoRoutes = require('./routes/pratos');

// 2. Configurar a aplica√ß√£o Express e Nexmo
const app = express();
const PORT = process.env.PORT || 3000;

// Configurar o Nexmo com suas credenciais do .env
const nexmo = new Nexmo({ 
    apiKey: process.env.VONAGE_API_KEY,
    apiSecret: process.env.VONAGE_API_SECRET
});

// Objeto para armazenar c√≥digos de verifica√ß√£o temporariamente (N√ÉO usar em produ√ß√£o)
const verificationCodes = {};

// 3. Middlewares
app.use(cors());
app.use(express.json());

// 4. Testar a conex√£o com o Prisma (opcional, mas √∫til)
(async () => {
    try {
        if (prisma) {
            await prisma.$connect();
            console.log('‚úÖ Conex√£o bem-sucedida com o PostgreSQL usando Prisma!');
        } else {
            console.log('‚ö†Ô∏è  PostgreSQL n√£o est√° dispon√≠vel. As APIs funcionar√£o mas retornar√£o erro espec√≠fico.');
        }
    } catch (err) {
        console.error('Erro na conex√£o com o banco de dados:', err);
    } finally {
        // Nada de desconectar o Prisma!
    }
})();

// =======================================================
// ROTAS DE USU√ÅRIOS - AUTENTICA√á√ÉO SEM SENHA
// =======================================================

// Fun√ß√£o utilit√°ria para gerar c√≥digo de verifica√ß√£o
function gerarCodigo() {
    return Math.floor(100000 + Math.random() * 900000).toString();
}

// üÜï Cadastro de usu√°rio
app.post('/api/usuarios/cadastro', async (req, res) => {
    try {
        const { nome, email, telefone } = req.body;

        if (!nome) {
            return res.status(400).json({
                sucesso: false,
                erro: 'Nome √© obrigat√≥rio'
            });
        }

        if (!email && !telefone) {
            return res.status(400).json({
                sucesso: false,
                erro: 'Email ou telefone √© obrigat√≥rio'
            });
        }

        // Verificar se usu√°rio j√° existe
        const usuarioExistente = await prisma.usuario.findFirst({
            where: {
                OR: [
                    email ? { email: email } : {},
                    telefone ? { telefone: telefone } : {}
                ]
            }
        });

        if (usuarioExistente) {
            return res.status(409).json({
                sucesso: false,
                erro: 'Usu√°rio j√° cadastrado com este email ou telefone'
            });
        }

        // Criar novo usu√°rio
        const novoUsuario = await prisma.usuario.create({
            data: {
                nome: nome.trim(),
                email: email || null,
                telefone: telefone || null,
                ativo: true
            },
            select: {
                id: true,
                nome: true,
                email: true,
                telefone: true,
                data_criacao: true
            }
        });

        console.log(`‚úÖ Usu√°rio cadastrado: ${nome} - ${email || telefone}`);

        res.status(201).json({
            sucesso: true,
            mensagem: 'Usu√°rio cadastrado com sucesso!',
            usuario: novoUsuario
        });

    } catch (error) {
        console.error('‚ùå Erro no cadastro:', error);
        res.status(500).json({
            sucesso: false,
            erro: 'Erro interno do servidor'
        });
    }
});

// üìß Enviar c√≥digo de verifica√ß√£o por email
app.post('/api/usuarios/codigo-email', async (req, res) => {
    try {
        const { email } = req.body;

        if (!email) {
            return res.status(400).json({
                sucesso: false,
                erro: 'Email √© obrigat√≥rio'
            });
        }

        // Buscar ou criar usu√°rio
        let usuario = await prisma.usuario.findUnique({
            where: { email: email }
        });

        if (!usuario) {
            usuario = await prisma.usuario.create({
                data: {
                    nome: `Usu√°rio ${email.split('@')[0]}`,
                    email: email,
                    ativo: true
                }
            });
            console.log(`üÜï Usu√°rio criado automaticamente: ${email}`);
        }

        // Gerar c√≥digo
        const codigo = gerarCodigo();
        const expiraEm = new Date(Date.now() + 15 * 60 * 1000); // 15 minutos

        // Atualizar usu√°rio com c√≥digo
        await prisma.usuario.update({
            where: { id: usuario.id },
            data: {
                codigo_verificacao: codigo,
                codigo_expira_em: expiraEm
            }
        });

        // Enviar email de verifica√ß√£o
        const emailResult = await emailService.sendVerificationEmail(email, codigo, usuario.nome);
        
        if (!emailResult.success) {
            console.error('‚ùå Erro ao enviar email:', emailResult.error);
            return res.status(500).json({
                sucesso: false,
                erro: 'Erro ao enviar email de verifica√ß√£o'
            });
        }

        console.log('üìß EMAIL DE VERIFICA√á√ÉO ENVIADO');
        console.log(`Email: ${email}`);
        console.log(`Message ID: ${emailResult.messageId}`);
        console.log('‚îÄ'.repeat(50));

        res.json({
            sucesso: true,
            mensagem: 'C√≥digo de verifica√ß√£o enviado para seu email'
        });

    } catch (error) {
        console.error('‚ùå Erro ao enviar c√≥digo por email:', error);
        res.status(500).json({
            sucesso: false,
            erro: 'Erro interno do servidor'
        });
    }
});

// üì± Enviar c√≥digo de verifica√ß√£o por SMS
app.post('/api/usuarios/codigo-sms', async (req, res) => {
    try {
        const { telefone } = req.body;

        if (!telefone) {
            return res.status(400).json({
                sucesso: false,
                erro: 'Telefone √© obrigat√≥rio'
            });
        }

        // Buscar ou criar usu√°rio
        let usuario = await prisma.usuario.findUnique({
            where: { telefone: telefone }
        });

        if (!usuario) {
            usuario = await prisma.usuario.create({
                data: {
                    nome: `Usu√°rio ${telefone}`,
                    telefone: telefone,
                    ativo: true
                }
            });
            console.log(`üÜï Usu√°rio criado automaticamente: ${telefone}`);
        }

        // Gerar c√≥digo
        const codigo = gerarCodigo();
        const expiraEm = new Date(Date.now() + 15 * 60 * 1000); // 15 minutos

        // Atualizar usu√°rio com c√≥digo
        await prisma.usuario.update({
            where: { id: usuario.id },
            data: {
                codigo_verificacao: codigo,
                codigo_expira_em: expiraEm
            }
        });

        console.log('üì± C√ìDIGO DE VERIFICA√á√ÉO POR SMS');
        console.log(`Telefone: ${telefone}`);
        console.log(`C√≥digo: ${codigo}`);
        console.log(`Expira: ${expiraEm.toLocaleString()}`);
        console.log('‚îÄ'.repeat(50));

        // Aqui voc√™ integraria com o Vonage/Nexmo para envio real do SMS
        // Por ora, apenas log para desenvolvimento

        res.json({
            sucesso: true,
            mensagem: 'C√≥digo de verifica√ß√£o enviado por SMS'
        });

    } catch (error) {
        console.error('‚ùå Erro ao enviar c√≥digo por SMS:', error);
        res.status(500).json({
            sucesso: false,
            erro: 'Erro interno do servidor'
        });
    }
});

// üîê Login com c√≥digo de verifica√ß√£o
app.post('/api/usuarios/login', async (req, res) => {
    try {
        const { identificador, codigo } = req.body;

        if (!identificador || !codigo) {
            return res.status(400).json({
                sucesso: false,
                erro: 'Identificador (email/telefone) e c√≥digo s√£o obrigat√≥rios'
            });
        }

        // Buscar usu√°rio por email ou telefone
        const usuario = await prisma.usuario.findFirst({
            where: {
                OR: [
                    { email: identificador },
                    { telefone: identificador }
                ]
            }
        });

        if (!usuario) {
            return res.status(404).json({
                sucesso: false,
                erro: 'Usu√°rio n√£o encontrado'
            });
        }

        if (!usuario.ativo) {
            return res.status(403).json({
                sucesso: false,
                erro: 'Conta desativada'
            });
        }

        // Verificar c√≥digo
        if (!usuario.codigo_verificacao || 
            usuario.codigo_verificacao !== codigo ||
            !usuario.codigo_expira_em ||
            new Date() > usuario.codigo_expira_em) {
            return res.status(400).json({
                sucesso: false,
                erro: 'C√≥digo inv√°lido ou expirado'
            });
        }

        // Verificar se √© a primeira verifica√ß√£o (para enviar email de boas-vindas)
        const isFirstVerification = !usuario.email_verificado && !usuario.telefone_verificado;

        // Atualizar usu√°rio (limpar c√≥digo e atualizar √∫ltimo login)
        const usuarioAtualizado = await prisma.usuario.update({
            where: { id: usuario.id },
            data: {
                codigo_verificacao: null,
                codigo_expira_em: null,
                ultimo_login: new Date(),
                email_verificado: identificador.includes('@') ? true : usuario.email_verificado,
                telefone_verificado: !identificador.includes('@') ? true : usuario.telefone_verificado
            },
            select: {
                id: true,
                nome: true,
                email: true,
                telefone: true,
                email_verificado: true,
                telefone_verificado: true,
                ultimo_login: true,
                avatar_url: true,
                provider: true
            }
        });

        // Enviar email de boas-vindas se for a primeira verifica√ß√£o e tiver email
        if (isFirstVerification && usuario.email) {
            try {
                await emailService.sendWelcomeEmail(usuario.email, usuario.nome);
                console.log(`üìß Email de boas-vindas enviado para: ${usuario.email}`);
            } catch (error) {
                console.error('‚ùå Erro ao enviar email de boas-vindas:', error);
                // N√£o falha o login por causa do email de boas-vindas
            }
        }

        console.log(`üîê Login realizado: ${usuario.nome} (${identificador})`);

        res.json({
            sucesso: true,
            mensagem: 'Login realizado com sucesso',
            token: `token_${usuario.id}_${Date.now()}`, // Em produ√ß√£o, use JWT real
            usuario: usuarioAtualizado
        });

    } catch (error) {
        console.error('‚ùå Erro no login:', error);
        res.status(500).json({
            sucesso: false,
            erro: 'Erro interno do servidor'
        });
    }
});

// üìã Listar usu√°rios
app.get('/api/usuarios', async (req, res) => {
    try {
        const usuarios = await prisma.usuario.findMany({
            where: { ativo: true },
            select: {
                id: true,
                nome: true,
                email: true,
                telefone: true,
                email_verificado: true,
                telefone_verificado: true,
                data_criacao: true,
                ultimo_login: true,
                provider: true,
                avatar_url: true
            },
            orderBy: { data_criacao: 'desc' }
        });

        res.json({
            sucesso: true,
            total: usuarios.length,
            usuarios: usuarios
        });
    } catch (error) {
        console.error('‚ùå Erro ao listar usu√°rios:', error);
        res.status(500).json({
            sucesso: false,
            erro: 'Erro interno do servidor'
        });
    }
});

// üîç Buscar usu√°rio por ID
app.get('/api/usuarios/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        
        if (isNaN(id)) {
            return res.status(400).json({
                sucesso: false,
                erro: 'ID inv√°lido'
            });
        }

        const usuario = await prisma.usuario.findFirst({
            where: { 
                id: id,
                ativo: true 
            },
            select: {
                id: true,
                nome: true,
                email: true,
                telefone: true,
                email_verificado: true,
                telefone_verificado: true,
                data_criacao: true,
                ultimo_login: true,
                provider: true,
                avatar_url: true
            }
        });

        if (!usuario) {
            return res.status(404).json({
                sucesso: false,
                erro: 'Usu√°rio n√£o encontrado'
            });
        }

        res.json({
            sucesso: true,
            usuario: usuario
        });
    } catch (error) {
        console.error('‚ùå Erro ao buscar usu√°rio:', error);
        res.status(500).json({
            sucesso: false,
            erro: 'Erro interno do servidor'
        });
    }
});

// ‚úèÔ∏è Atualizar usu√°rio
app.put('/api/usuarios/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        const { nome, telefone } = req.body;
        
        if (isNaN(id)) {
            return res.status(400).json({
                sucesso: false,
                erro: 'ID inv√°lido'
            });
        }

        const usuario = await prisma.usuario.findFirst({
            where: { 
                id: id,
                ativo: true 
            }
        });

        if (!usuario) {
            return res.status(404).json({
                sucesso: false,
                erro: 'Usu√°rio n√£o encontrado'
            });
        }

        const dadosAtualizacao = {};
        if (nome) dadosAtualizacao.nome = nome.trim();
        if (telefone) dadosAtualizacao.telefone = telefone;

        const usuarioAtualizado = await prisma.usuario.update({
            where: { id: id },
            data: dadosAtualizacao,
            select: {
                id: true,
                nome: true,
                email: true,
                telefone: true
            }
        });

        console.log(`üìù Usu√°rio atualizado: ${usuarioAtualizado.nome} (ID: ${id})`);

        res.json({
            sucesso: true,
            mensagem: 'Usu√°rio atualizado com sucesso',
            usuario: usuarioAtualizado
        });
    } catch (error) {
        console.error('‚ùå Erro ao atualizar usu√°rio:', error);
        res.status(500).json({
            sucesso: false,
            erro: 'Erro interno do servidor'
        });
    }
});

// üóëÔ∏è Desativar usu√°rio (soft delete)
app.delete('/api/usuarios/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id);
        
        if (isNaN(id)) {
            return res.status(400).json({
                sucesso: false,
                erro: 'ID inv√°lido'
            });
        }

        const usuario = await prisma.usuario.findFirst({
            where: { 
                id: id,
                ativo: true 
            }
        });

        if (!usuario) {
            return res.status(404).json({
                sucesso: false,
                erro: 'Usu√°rio n√£o encontrado'
            });
        }

        await prisma.usuario.update({
            where: { id: id },
            data: { ativo: false }
        });

        console.log(`üóëÔ∏è Usu√°rio desativado: ${usuario.nome} (ID: ${id})`);

        res.json({
            sucesso: true,
            mensagem: 'Usu√°rio desativado com sucesso'
        });
    } catch (error) {
        console.error('‚ùå Erro ao desativar usu√°rio:', error);
        res.status(500).json({
            sucesso: false,
            erro: 'Erro interno do servidor'
        });
    }
});

// =======================================================
// ROTAS DE FACEBOOK OAUTH 2.0
// =======================================================

// üîó Obter URL de login do Facebook
app.get('/api/auth/facebook/url', (req, res) => {
    try {
        const { redirect_uri } = req.query;

        if (!redirect_uri) {
            return res.status(400).json({
                sucesso: false,
                erro: 'redirect_uri √© obrigat√≥rio'
            });
        }

        const facebookAppId = process.env.FACEBOOK_APP_ID || 'sua_app_id_facebook';
        const scope = 'email,public_profile';
        
        const authUrl = `https://www.facebook.com/v18.0/dialog/oauth?` +
            `client_id=${facebookAppId}&` +
            `redirect_uri=${encodeURIComponent(redirect_uri)}&` +
            `scope=${scope}&` +
            `response_type=code&` +
            `state=worldbite_${Date.now()}`;

        console.log('üîó URL de login Facebook gerada');

        res.json({
            sucesso: true,
            auth_url: authUrl,
            app_id: facebookAppId,
            redirect_uri: redirect_uri
        });

    } catch (error) {
        console.error('‚ùå Erro ao gerar URL Facebook:', error);
        res.status(500).json({
            sucesso: false,
            erro: 'Erro interno do servidor'
        });
    }
});

// üì± Callback do Facebook OAuth
app.post('/api/auth/facebook/callback', async (req, res) => {
    try {
        const { code, redirect_uri } = req.body;

        if (!code || !redirect_uri) {
            return res.status(400).json({
                sucesso: false,
                erro: 'C√≥digo e redirect_uri s√£o obrigat√≥rios'
            });
        }

        console.log('üì± Callback Facebook recebido');
        console.log(`C√≥digo: ${code.substring(0, 20)}...`);

        // Simular dados do Facebook (em produ√ß√£o, fa√ßa a troca real do c√≥digo por token)
        const facebookUser = {
            id: `fb_${Date.now()}`,
            name: 'Usu√°rio Facebook',
            email: 'usuario.facebook@exemplo.com',
            picture: {
                data: {
                    url: 'https://via.placeholder.com/150'
                }
            }
        };

        // Buscar ou criar usu√°rio
        let usuario = await prisma.usuario.findUnique({
            where: { facebook_id: facebookUser.id }
        });
        
        let novoUsuario = false;

        if (!usuario) {
            // Verificar se j√° existe usu√°rio com mesmo email
            const usuarioExistente = await prisma.usuario.findUnique({
                where: { email: facebookUser.email }
            });

            if (usuarioExistente) {
                // Vincular conta Facebook ao usu√°rio existente
                usuario = await prisma.usuario.update({
                    where: { id: usuarioExistente.id },
                    data: {
                        facebook_id: facebookUser.id,
                        avatar_url: facebookUser.picture.data.url,
                        provider: 'facebook',
                        ultimo_login: new Date(),
                        email_verificado: true
                    }
                });
            } else {
                // Criar novo usu√°rio
                usuario = await prisma.usuario.create({
                    data: {
                        nome: facebookUser.name,
                        email: facebookUser.email,
                        facebook_id: facebookUser.id,
                        avatar_url: facebookUser.picture.data.url,
                        provider: 'facebook',
                        email_verificado: true,
                        ativo: true,
                        ultimo_login: new Date()
                    }
                });
                novoUsuario = true;
            }
            
            console.log(`üÜï ${novoUsuario ? 'Novo usu√°rio criado' : 'Conta vinculada'} via Facebook: ${usuario.nome}`);
        } else {
            // Atualizar √∫ltimo login
            usuario = await prisma.usuario.update({
                where: { id: usuario.id },
                data: { ultimo_login: new Date() }
            });
            console.log(`üîê Login via Facebook: ${usuario.nome}`);
        }

        const token = `facebook_token_${usuario.id}_${Date.now()}`;

        res.json({
            sucesso: true,
            mensagem: 'Login com Facebook realizado com sucesso',
            token: token,
            usuario: {
                id: usuario.id,
                nome: usuario.nome,
                email: usuario.email,
                avatar_url: usuario.avatar_url,
                provider: usuario.provider,
                email_verificado: usuario.email_verificado
            },
            novo_usuario: novoUsuario
        });

    } catch (error) {
        console.error('‚ùå Erro no callback Facebook:', error);
        res.status(500).json({
            sucesso: false,
            erro: 'Erro interno do servidor'
        });
    }
});

// üìä Status da API
app.get('/api/status', async (req, res) => {
    try {
        const totalUsuarios = await prisma.usuario.count({
            where: { ativo: true }
        });

        const totalRestaurantes = await prisma.restaurante.count({
            where: { ativo: true }
        });

        res.json({
            status: 'OK',
            mensagem: 'üöÄ World Bite API - Servidor com PostgreSQL',
            modo: 'PRODU√á√ÉO (Dados persistentes)',
            usuarios_cadastrados: totalUsuarios,
            restaurantes_cadastrados: totalRestaurantes,
            banco_dados: 'PostgreSQL + Prisma',
            apis: {
                usuarios: {
                    cadastro: 'POST /api/usuarios/cadastro',
                    codigo_email: 'POST /api/usuarios/codigo-email',
                    codigo_sms: 'POST /api/usuarios/codigo-sms',
                    login: 'POST /api/usuarios/login',
                    listar: 'GET /api/usuarios',
                    buscar: 'GET /api/usuarios/:id',
                    atualizar: 'PUT /api/usuarios/:id',
                    desativar: 'DELETE /api/usuarios/:id'
                },
                facebook: {
                    login_url: 'GET /api/auth/facebook/url?redirect_uri=URL',
                    callback: 'POST /api/auth/facebook/callback'
                },
                restaurantes: {
                    send_verification: 'POST /api/send-verification-code',
                    verify_code: 'POST /api/verify-code',
                    login_rapido: 'POST /api/login-rapido'
                }
            },
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        console.error('‚ùå Erro no status:', error);
        res.status(500).json({
            sucesso: false,
            erro: 'Erro interno do servidor'
        });
    }
});

// =======================================================
// ROTAS P√öBLICAS (CADASTRO E LOGIN)
// =======================================================

// --- Rota para criar um novo restaurante (CRUD: CREATE) ---
app.post('/restaurantes', async (req, res) => {
    // ... C√ìDIGO DA ROTA DE CADASTRO DE RESTAURANTE ... (inalterado)
});

// --- Rota para enviar o c√≥digo de verifica√ß√£o por CNPJ ---
app.post('/api/send-verification-code', async (req, res) => {
    const { cnpj } = req.body;

    if (!cnpj) {
        return res.status(400).json({ error: 'CNPJ √© obrigat√≥rio.' });
    }

    const cnpjLimpo = cnpj.replace(/[^\d]/g, '');

    try {
        const restaurante = await prisma.restaurante.findUnique({
            where: { cnpj: cnpjLimpo },
            select: { telefone_contato: true, nome: true }
        });

        if (!restaurante) {
            return res.status(404).json({ error: 'Restaurante n√£o encontrado.' });
        }

        const verificationCode = Math.floor(1000 + Math.random() * 9000).toString();
        const phoneNumber = restaurante.telefone_contato;

        verificationCodes[cnpjLimpo] = verificationCode;

        const from = "World Bite";
        const to = phoneNumber;
        const text = `Seu c√≥digo de verifica√ß√£o World Bite √©: ${verificationCode}`;

        nexmo.message.sendSms(from, to, text, (err, responseData) => {
            if (err) {
                console.error('Erro na API do Nexmo:', err);
                return res.status(500).json({ error: 'Erro no envio do SMS.' });
            }
            if (responseData.messages[0]['status'] === "0") {
                console.log(`Mensagem enviada com sucesso para ${to}`);
                res.status(200).json({ message: 'C√≥digo de verifica√ß√£o enviado!' });
            } else {
                console.error('Erro no envio do SMS:', responseData.messages[0]['error-text']);
                res.status(500).json({ error: 'Erro no envio do SMS.' });
            }
        });

    } catch (err) {
        console.error('Erro geral ao processar a requisi√ß√£o:', err);
        res.status(500).json({ error: 'Erro interno do servidor.' });
    }
});

// --- Rota para verificar o c√≥digo e autenticar o usu√°rio ---
app.post('/api/verify-code', async (req, res) => {
    const { cnpj, code } = req.body;

    if (!cnpj || !code) {
        return res.status(400).json({ error: 'CNPJ e c√≥digo de verifica√ß√£o s√£o obrigat√≥rios.' });
    }
    
    const cnpjLimpo = cnpj.replace(/[^\d]/g, '');

    const storedCode = verificationCodes[cnpjLimpo];

    if (!storedCode || storedCode !== code.trim()) {
        return res.status(401).json({ error: 'C√≥digo de verifica√ß√£o inv√°lido.' });
    }
    
    const restaurante = await prisma.restaurante.findUnique({
        where: { cnpj: cnpjLimpo },
        select: { nome: true }
    });
    
    // delete verificationCodes[cnpjLimpo]; // Descomente para produ√ß√£o

    res.status(200).json({ 
        success: true, 
        message: 'Login bem-sucedido!', 
        nomeRestaurante: restaurante ? restaurante.nome : 'Restaurante',
        token: 'seu-token-de-autenticacao' 
    });
});

// üîë ROTA DE LOGIN R√ÅPIDO AGORA EST√Å AQUI (antes das rotas protegidas)
app.post('/api/login-rapido', async (req, res) => {
    const { cnpj } = req.body;

    if (!cnpj) {
        return res.status(400).json({ error: 'CNPJ √© obrigat√≥rio.' });
    }

    try {
        const cnpjLimpo = cnpj.replace(/[^\d]/g, '');
        
        const restaurante = await prisma.restaurante.findUnique({
            where: { cnpj: cnpjLimpo },
        });

        if (!restaurante) {
            return res.status(404).json({ error: 'Restaurante n√£o encontrado.' });
        }

        const codigoFixo = '1234'; 
        verificationCodes[cnpjLimpo] = codigoFixo;

        console.log(`[DEV MODE] C√≥digo Fixo ${codigoFixo} armazenado para CNPJ: ${cnpjLimpo}`);

        res.status(200).json({ 
            message: `Login r√°pido ativado! Use o c√≥digo ${codigoFixo}.` 
        });

    } catch (err) {
        console.error('Erro no login r√°pido:', err);
        res.status(500).json({ error: 'Erro interno do servidor.' });
    }
});

// =======================================================
// ROTA DE TESTE DE EMAIL
// =======================================================

app.get('/api/test-email', async (req, res) => {
    try {
        console.log('üß™ Testando configura√ß√£o de email...');
        
        // Testar conex√£o
        const connectionTest = await emailService.testConnection();
        
        if (!connectionTest.success) {
            return res.status(500).json({
                sucesso: false,
                erro: 'Falha na conex√£o com servidor de email',
                detalhes: connectionTest.error
            });
        }

        // Enviar email de teste se foi fornecido um email na query
        const { email } = req.query;
        if (email) {
            const emailResult = await emailService.sendVerificationEmail(email, '123456', 'Teste');
            return res.json({
                sucesso: true,
                mensagem: 'Teste de email conclu√≠do',
                conexao: connectionTest,
                email: emailResult
            });
        }

        res.json({
            sucesso: true,
            mensagem: 'Conex√£o com servidor de email OK',
            conexao: connectionTest,
            dica: 'Use ?email=seuemail@teste.com para testar envio'
        });

    } catch (error) {
        console.error('‚ùå Erro no teste de email:', error);
        res.status(500).json({
            sucesso: false,
            erro: 'Erro interno no teste de email',
            detalhes: error.message
        });
    }
});

// =======================================================
// ROTAS PROTEGIDAS (REQUER AUTH)
// =======================================================

// üîë INTEGRA√á√ÉO DO CRUD DE PRATOS
app.use('/api/restaurante/prato', pratoRoutes); 

// üè† Rota principal
app.get('/', (req, res) => {
    res.json({
        mensagem: 'World Bite API - Servidor Unificado',
        status: 'Funcionando com PostgreSQL + Prisma',
        documentacao: 'GET /api/status',
        versao: '2.0.0 - Consolidado'
    });
});

// 5. Iniciar o servidor
app.listen(PORT, () => {
    console.log(`Servidor rodando em http://localhost:${PORT}`);
});